% -*- LaTeX -*-
% -*- coding: utf-8 -*-
%
% michael a.g. aïvázis <michael.aivazis@para-sim.com>
% (c) 2003-2017 all rights reserved
%

\section{components}
\subsection{basics}

% --------------------------------------
% components:
\begin{frame}
%
  \frametitle{Extending object oriented ideas}
%
  \begin{itemize}
%
  \item most of the \pyre\ services are organized using \emph{objects}
%
  \item informally, \emph{classes} are software specifications that establish a relationship
    between \emph{state} and \emph{behavior}
    \begin{itemize}
    \item we have syntax that allows us to specify these very close to each other
    \end{itemize}
%
  \item \emph{instances} are containers of state; there are special rules
    \begin{itemize}
    \item that grant access to this state
    \item allow you to call functions that get easy access to this state
    \item it is worth remembering that python classes are themselves live objects: they
      are instances of their \emph{type}
    \end{itemize}
%
  \item these ideas have been around for a while\supercite{dahl-66,eiffel}, and have been
    explored extensively and formalized\supercite{meyer-97}
%
  \item \pyre\ \emph{components} are classes that specifically grant access to some of their
    state to the end user
    \begin{itemize}
    \item the public data are the \emph{properties} of the component
    \end{itemize}
%
  \item the notion is quite old\supercite{mcilroy-69} and the terms heavily overloaded; \pyre\
    components are an evolution of these ideas
%
  \end{itemize}
%
\end{frame}

%-----------------------------------
\begin{frame}
%
  \frametitle{SRTM -- the module}
%
  \begin{center}
    \only<1>{\includegraphics[width=1.0\textwidth]{component-package}}
    \only<2->{\includegraphics[width=1.0\textwidth]{component-package-explained}}
  \end{center}
%
\end{frame}

%-----------------------------------
\begin{frame}
%
  \frametitle{Turning classes into components}
%
  \begin{center}
    \only<1>{\includegraphics[width=1.0\textwidth]{component-base}}
    \only<2>{\includegraphics[width=1.0\textwidth]{component-inheritance}}
    \only<3>{\includegraphics[width=1.0\textwidth]{component-inheritance-explained}}
  \end{center}
%
\end{frame}

%-----------------------------------
\begin{frame}[fragile]
%
  \frametitle{Component declaration}
%
  \vskip -3ex
  \begin{itemize}
%
  \item the instruction
    \begin{center}
      \includegraphics[height=10ex]{srtm-pedigree}
    \end{center}
%
  \item implies that instead of
%
    \begin{ipython}[gobble=6]{}
      class SRTM:
          """
          Access the SRTM data archive to download tiles and produce
          a digital elevation model for a specified region of interest
          """
    \end{ipython}
%
  \item we have to import the \isce\ package and derive from \class{isce.component}:
    \begin{ipython}[gobble=6]{}
      # support
      import isce

      # the srtm component
      class SRTM(isce.component):
          """
          Access the SRTM data archive to download tiles and produce
          a digital elevation model for a specified region of interest
          """
    \end{ipython}
%
  \end{itemize}
%
\end{frame}

% --------------------------------------
\subsection{properties}

% properties
\begin{frame}[fragile]
%
  \frametitle{Specifying the tile resolution}
  \vskip -3ex
%
  \begin{itemize}
%
  \item version 3 \srtm\ tiles come in two resolutions; enable the user to choose
%
    \begin{ipython}[firstnumber=4, gobble=6]{}
      # the srtm component
      class SRTM(isce.component):
          """
          Access the SRTM data archive to download tiles and produce
          a digital elevation model for a specified region of interest
          """

          # user configurable state
          resolution = 1 # arc seconds per pixel
    \end{ipython}
%
  \item how do we read the value of \trait{resolution} from a configuration file?
%
    \begin{ipfg}{}
      srtm:
          resolution = 1 ; arc seconds per pixel
    \end{ipfg}
%
    or, equivalently, from the command line of some driver script?
%
    \begin{ish}{}
      dem.py --srtm.resolution=1
    \end{ish}
%
  \item there are two ingredients missing:
    \begin{itemize}
    \item \trait{resolution} must become a \emph{property} of \component{SRTM}
    \item \component{SRTM} and its instances need \emph{names} so the user can refer to them
    \end{itemize}
%
  \end{itemize}
%
\end{frame}

% --------------------------------------
% properties
\begin{frame}
%
  \frametitle{Components have properties}
%
  \begin{center}
    \only<1>{\includegraphics[width=1.0\textwidth]{component-properties}}
    \only<2->{\includegraphics[width=1.0\textwidth]{component-properties-explained}}
  \end{center}
%
\end{frame}

% --------------------------------------
\begin{frame}[fragile]
%
  \frametitle{Property declarations}
%
  \vskip -4ex
  \begin{itemize}
%
  \item the instruction
%
    \begin{center}
      \includegraphics[height=10ex]{srtm-resolution}
    \end{center}
%
  \item implies the following modification to the \component{SRTM} declaration:
%
    \begin{ipython}[firstnumber=4, gobble=6]{}
      # the srtm component
      class SRTM(isce.component):
          """
          Access the SRTM data archive to download tiles and produce
          a digital elevation model for a specified region of interest
          """

          # user configurable state
          resolution = isce.properties.int(default=1)
          resolution.doc = 'the tile resolution in arc seconds per pixel'
    \end{ipython}
%
  \item why bother specifying the type of component properties?
    \begin{itemize}
    \item command line, configuration files, dialog boxes, web pages: they all gather
      information from the user as strings
    \item we need \emph{meta-data} so we can convert from strings to the intended object
    \end{itemize}
%
  \end{itemize}
%
\end{frame}

% --------------------------------------
\begin{frame}
%
  \frametitle{Properties}
%
  \vskip -2ex
  \begin{itemize}
%
  \item properties make sense for both classes and instances
    \begin{itemize}
    \item the class holds the default value that gets used in case the component instance does
      not have explicit configuration
    \item each instance gets its own private value when it gets configured
    \item the behavior is identical to regular python attributes
    \end{itemize}
%
  \item there is support for the following \emph{schemata}
    \begin{itemize}
    \item simple types: \schema{bool}, \schema{int}, \schema{float}, \schema{decimal},
      \schema{fraction}, \schema{str}
    \item containers: \schema{tuple}, \schema{list}, \schema{set}, \schema{array}
    \item higher level: \schema{date}, \schema{path}, \schema{uri}, \schema{time}, \schema{istream},
      \schema{ostream}, \schema{inet}
    \item units: \schema{dimensional}
    \item composites: \schema{strings}, \schema{paths}, \schema{uris}
    \item easy enough to implement your own; the requirements are very simple
    \end{itemize}
%
  \item metadata:
    \begin{itemize}
    \item \identifier{doc} and \identifier{tip}: simple and short documentation strings
    \item \identifier{default}: the default value, in case the user doesn't supply one
    \item \identifier{converters}: a chain of preprocessors of the string representation
    \item \identifier{normalizers}: a chain of post-processors of the converted value
    \item \identifier{validators}: a tuple of predicates that get called to ensure the property
      value satisfies the specified constraints
    \item you can add your own; the framework passes them through to your component
    \end{itemize}
%
  \end{itemize}
%
\end{frame}

%-----------------------------------
% values
\begin{frame}[fragile]
%
  \frametitle{Specifying property values}
%
  \vskip -4ex
  \begin{itemize}
%
  \item the value \keyword{None} is special: it means a property is uninitialized
    \begin{itemize}
    \item recognized as either \keyword{None} or as \literal{'None'}
    \item it is a legal value for any trait
    \end{itemize}
%
  \item a property can be assigned a value that
    \begin{itemize}
    \item is already its native type
    \item can be converted to this native type by the trait schema
    \end{itemize}
%
  \item all property types recognize and process strings
    \begin{itemize}
    \item \schema{bool} recognizes
      \literal{'true'}/\literal{'false'},
      \literal{'on'}/\literal{'off'},
      \literal{'yes'}/\literal{'no'} in any combination of upper case and lower case letters
    \item \schema{int} and \schema{float} evaluate simple expressions
    \item \schema{date} and \schema{time} let you specify a format string to use when parsing
      input
    \item \schema{istream} and \schema{ostream} interpret strings as filenames and open an
      associated stream
    \item \schema{path} and \schema{uri} have specialized parsers that convert strings to their
      internal representations of paths
    \end{itemize}
%
  \item string values may refer to other properties by name, so something like this could work
    \begin{ipython}[gobble=2]{}
      srtm.resolution = "3600 / {tile.width}"
    \end{ipython}
    so arithmetic can be done in configuration files -- and the command line
%
  \end{itemize}
%
\end{frame}

%-----------------------------------
% containers
\begin{frame}[fragile]
%
  \frametitle{Containers}
%
  \vskip -4ex
  \begin{itemize}
%
  \item there are three basic container types: \schema{tuple}, \schema{list} and \schema{set}
%
  \item you must supply the type of the contained item so conversions can happen correctly
%
  \item given the component declaration
    \begin{ipython}[gobble=4]{}
      class Band(isce.component):
          """
          An illustration of property containers
          """

          names = isce.properties.tuple(schema=isce.properties.str())
          names.default = 'john, paul, george, ringo'
    \end{ipython}
%
    the code fragment
    \begin{ipython}[firstnumber=9, gobble=4]{}
      beatles = Band(name='beatles') # more on instantiating components later on
      print(beatles.names)
    \end{ipython}
%
    produces
%
    \begin{ish}[firstnumber=12]{}
     >>>
     ['john', 'paul', 'george', 'ringo']
     >>>
    \end{ish}
%
    more sophisticated -- and realistic -- examples coming up
%
  \item \schema{array} passes its values through \function{eval}; it accepts any expression that
    evaluates into an iterable without doing much error checking
%
  \end{itemize}
%
\end{frame}

% --------------------------------------
% units
\begin{frame}[fragile]
%
  \frametitle{Units}
%
  \vskip -3ex
  \begin{itemize}
%
  \item \schema{dimensional} properties have units
%
  \item the low level support is in \package{isce.units}
    \begin{itemize}
    \item full support for all SI base and derived units
    \item all common abbreviations and names from alternative systems of units
    \item correct arithmetic; proper handling of functions from \package{math}
    \end{itemize}
%
  \item consider
    \begin{ipython}[gobble=6]{}
      from math import cos
      from isce.units.SI import meter, second, radian

      A = 2.5 * meter
      t = 1.5 * second
      ω = 4.2 * radian/second

      x = A * cos(ω * t)
     \end{ipython}
%
   \item an exception is raised if the units in the argument to \function{cos} do not cancel,
     leaving a pure \keyword{float} behind; \identifier{x} has dimensions of meters
%
   \item there is some control over the printing value
%
    \begin{ipython}[firstnumber=9, gobble=6]{}
      pretty = '{:value=.2f, base={scale}, label=cm}'.format(x, scale=meter/100)
    \end{ipython}
%
  \end{itemize}
%
\end{frame}

% --------------------------------------
% constraints
\begin{frame}[fragile]
%
  \frametitle{Constraints}
%
  \begin{itemize}
%
  \item there are only two valid values for \trait{resolution}
%
    \begin{ipython}[firstnumber=4, gobble=6]{}
      # the srtm component
      class SRTM(isce.component):
          """
          Access the SRTM data archive to download tiles and produce
          a digital elevation model for a specified region of interest
          """

          # user configurable state
          resolution = isce.properties.int(default=1)
          resolution.doc = 'the tile resolution in arc seconds per pixel'
          resolution.validators = isce.constraints.isMember(1, 3)
    \end{ipython}
%
    any attempt to set \trait{resolution} to a value other than $1$ or $3$ will raise an
    exception
%
  \item the full list of primitives are
    \begin{itemize}
    \item \constraint{isEqual}, \constraint{isGreater},
      \constraint{isGreaterEqual},\constraint{isLess}, \constraint{isLessEqual}
    \item \constraint{isPositive}, \constraint{isNegative}, \constraint{isBetween}
    \item \constraint{isMember}, \constraint{isSubset}, \constraint{isLike}
    \end{itemize}
%
  \item they can be combined using
    \begin{itemize}
    \item \constraint{isNot}
    \item \constraint{isAll}, \constraint{isAny}
    \end{itemize}
%
  \item easy to extend
%
  \end{itemize}
%
\end{frame}

%-----------------------------------

\begin{frame}[fragile]
%
  \frametitle{Specifying the region}
%
  \vskip -4ex
  \begin{itemize}
%
  \item let's add the \trait{region} requirement
%
    \begin{center}
      \includegraphics[height=15ex]{srtm-region}
    \end{center}
%
  \item the \component{SRTM} declaration becomes:
%
    \begin{ipython}[firstnumber=4, gobble=6]{}
      # the srtm component
      class SRTM(isce.component):
          """
          Access the SRTM data archive to download tiles and produce
          a digital elevation model for a specified region of interest
          """

          # user configurable state
          resolution = isce.properties.int(default=1)
          resolution.doc = 'the tile resolution in arc seconds per pixel'
          resolution.validators = isce.constraints.isMember(1, 3)

          region = isce.properties.array()
          region.doc = 'a cloud of (lat,lon) pairs'
    \end{ipython}
%
  \end{itemize}
%
\end{frame}

%-----------------------------------

\begin{frame}
%
  \frametitle{More notation}
  \vskip -3ex
%
  \begin{itemize}
%
  \item when we don't care to show the binding slots, here is a more compact alternative to the
    property declarations
%
    \begin{center}
      \includegraphics[height=10ex]{srtm-properties-compact}
    \end{center}
%
%
  \item sometimes we need to communicate the values to which properties are bound
%
    \begin{center}
      \includegraphics[height=10ex]{srtm-properties-bound}
    \end{center}
%
  \item when we don't need the connectors, we can be more compact
%
    \begin{center}
      \includegraphics[height=10ex]{srtm-properties-bound-compact}
    \end{center}
%
  \end{itemize}
%
\end{frame}

% --------------------------------------
\subsection{behaviors}

%-----------------------------------
\subsection{names}
\begin{frame}
%
  \frametitle{SRTM -- family}
%
  \begin{center}
    \only<1>{\includegraphics[width=1.0\textwidth]{component-family}}
    \only<2>{\includegraphics[width=1.0\textwidth]{component-family-explained}}
  \end{center}
%
\end{frame}

% --------------------------------------
% recap
\begin{frame}
%
  \frametitle{Recap: what we know so far}
%
  \begin{itemize}
%
  \item \pyre\ components are evolved python objects
    \begin{itemize}
    \item the classes have family names, the instances have names
    \item these names are unique strings in hierarchical namespaces delimited by periods
    \item collections of components form packages \emph{implicitly}, based on the topmost level
      in their namespace
    \end{itemize}
%
  \item components have properties that are under the control of the \emph{user}
    \begin{itemize}
    \item they look and behave like regular attributes
    \item they are \emph{typed} to enable conversions from strings
    \item they have default values and other metadata
    \end{itemize}
%
  \item configuration is partly about assigning values to component properties
    \begin{itemize}
    \item a requirement for supporting user interfaces
    \item intuitive syntax for the command line
    \item simple configuration files in a variety of formats:
      \begin{itemize}
      \item \identifier{pfg}: the preferred native format
      \item \identifier{pml}: an \identifier{XML} dialect
      \item \identifier{cfg}: a format inspired by the Microsoft Windows \identifier{.ini} format
      \end{itemize}
    \end{itemize}
%
  \item configuration is automatically handled by the framework and requires no explicit
    involvement on the part of the component author
%
  \end{itemize}
%
\end{frame}

% --------------------------------------
\subsection{protocols}
\begin{frame}
%
  \frametitle{Components and protocols}
%
  \begin{itemize}
%
  \item a design pattern\supercite{patterns} that enables the assembly of applications out of
    interchangeable parts, under the control of the end user
      \begin{itemize}
      \item \emph{protocols} are abstract specifications of application requirements
      \item \emph{components} are concrete implementations that satisfy requirements
      \end{itemize}
%
    \item protocols make it possible to write applications without any \emph{a priori} knowledge
      of implementation specifics
%
    \item inversion of control\supercite{johnson-88}:
      \begin{itemize}
      \item the binding of actual implementations to the application requirements happens at
        runtime, under the control of the end user
      \end{itemize}
%
    \item in \pyre, the user
      \begin{itemize}
      \item controls the application state through configuration files, the user interface, the
        command line
      \item specifies components using simple URIs
      \end{itemize}
%
    \item the goal is to isolate contributors from each other as much as possible, and provide
      a coherent and usable strategy for composing non-trivial applications
%
  \end{itemize}
%
\end{frame}

%-----------------------------------
\begin{frame}
%
  \frametitle{SRTM - protocol}
%
  \begin{center}
    \only<1>{\includegraphics[width=1.0\textwidth]{component-implements}}
    \only<2>{\includegraphics[width=1.0\textwidth]{component-implements-explained}}
  \end{center}
%
\end{frame}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../pyre"
%%% End:

% end of file
