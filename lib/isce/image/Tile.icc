// -*- C++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// (c) 2003-2016 all rights reserved
//

// code guard
#if !defined(isce_image_Tile_icc)
#error This header file contains implementation details of class isce::image::Tile
#endif


// meta-methods
isce::image::Tile::
Tile(shape_t shape, layout_t layout) :
    _shape{shape},
    _layout{layout}
{}


// interface

// accessors
size_t
isce::image::Tile::
lines() const {
    // the number of lines is the zeroth item in _shape
    return _shape[0];
}

size_t
isce::image::Tile::
samples() const {
    // the number of samples is the first item in _shape
    return _shape[1];
}

size_t
isce::image::Tile::
bands() const {
    // the number of bands is the second item in _shape
    return _shape[2];
}

size_t
isce::image::Tile::
pixels() const {
    // initialize the size
    size_t pixels = 1;
    // go through my shape
    for (size_t dim=0; dim < _shape.size(); ++dim) {
        // scale the size up by the extent of this dimension
        pixels *= _shape[dim];
    }
    // all done
    return pixels;
}

// indexed access
size_t
isce::image::Tile::
operator[](index_t index) const {
    // initialize the offset
    size_t offset = 0;
    // and the running product
    size_t product = 1;
    // loop over the packing order
    for (auto dim : _layout) {
        // update the offset
        offset += index[dim] * product;
        // update the product
        product *= _shape[dim];
    }
    // all done
    return offset;
}

isce::image::Tile:: index_t
isce::image::Tile::
index(size_t offset) const {
    // storage for the answer
    size_t index[_dim];
    // initialize the product
    size_t product = pixels();

    // loop in reverse packing order
    for (int dim = _dim-1; dim >=0; --dim) {
        // pull the current shape limit out of the product
        product /= _shape[_layout[dim]];
        // compute the index
        index[_layout[dim]] = offset / product;
        // adjust the offset
        offset %= product;
    }

    // build an index and return it
    return index_t {index[0], index[1], index[2]};
}


// iteration support
isce::image::Tile::iterator_t
isce::image::Tile::
begin() const {
    // build a packing-order iterator pointing to the beginning of the tile
    return iterator_t(_shape, _layout);
}

isce::image::Tile::iterator_t
isce::image::Tile::
end() const {
    // build an iterator pointing to the end of the tile
    return iterator_t(_shape, _shape, _layout);
}

isce::image::Tile::iterator_t
isce::image::Tile::
order(layout_t order) const {
    // build an arbitrary order iterator pointing to the beginning of the tile
    return iterator_t(_shape, order);
}

// end of file
