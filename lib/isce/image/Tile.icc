// -*- C++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// (c) 2003-2016 all rights reserved
//

// code guard
#if !defined(isce_image_Tile_icc)
#error This header file contains implementation details of class isce::image::Tile
#endif


// meta-methods
isce::image::Tile::
Tile(shape_t shape, layout_t layout) :
    _shape{shape},
    _layout{layout}
{}


// interface
// accessors
isce::image::Tile::shape_t
isce::image::Tile::
shape() const {
    // return my shape
    return _shape;
}

isce::image::Tile::layout_t
isce::image::Tile::
layout() const {
    // return my layout
    return _layout;
}


// derivative accessors
size_t
isce::image::Tile::
lines() const {
    // the number of lines is the zeroth item in _shape
    return _shape[line];
}

size_t
isce::image::Tile::
samples() const {
    // the number of samples is the first item in _shape
    return _shape[sample];
}

size_t
isce::image::Tile::
bands() const {
    // the number of bands is the second item in _shape
    return _shape[band];
}

size_t
isce::image::Tile::
pixels() const {
    // initialize the size
    size_t pixels = 1;
    // go through my shape
    for (auto size : _shape) {
        // scale the size up by the extent of this dimension
        pixels *= size;
    }
    // all done
    return pixels;
}

// indexed access
size_t
isce::image::Tile::
offset(index_t index) const {
    // initialize the offset
    size_t offset = 0;
    // and the running product
    size_t product = 1;
    // loop over the packing order
    for (auto dim : _layout) {
        // update the offset
        offset += index[dim] * product;
        // update the product
        product *= _shape[dim];
    }
    // all done
    return offset;
}

isce::image::Tile:: index_t
isce::image::Tile::
index(size_t offset) const {
    // storage for the answer
    index_t::rep_t index;
    // initialize the product
    auto product = pixels();

    // loop in reverse packing order
    for (int dim = _dim-1; dim >=0; --dim) {
        // pull the current shape limit out of the product
        product /= _shape[_layout[dim]];
        // compute the index
        index[_layout[dim]] = offset / product;
        // adjust the offset
        offset %= product;
    }

    // build an index and return it
    return index_t {index};
}


// indexed access
size_t
isce::image::Tile::
operator[](index_t index) const {
    // delegate
    return this->offset(index);
}

isce::image::Tile:: index_t
isce::image::Tile::
operator[](size_t offset) const {
    // delegate
    return this->index(offset);
}


// iteration support
isce::image::Tile::iterator_t
isce::image::Tile::
begin() const {
    // build a packing-order iterator pointing to the beginning of the tile
    return iterator_t(_shape, _layout);
}

isce::image::Tile::iterator_t
isce::image::Tile::
end() const {
    // build an iterator pointing to the end of the tile
    return iterator_t(_shape, _shape, _layout);
}

isce::image::Tile::tile_t
isce::image::Tile::
order(const layout_t & order) const {
    // build an arbitrary order iterator pointing to the beginning of the tile
    return tile_t(_shape, order);
}

// end of file
